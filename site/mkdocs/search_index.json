{
    "docs": [
        {
            "location": "/index.html",
            "text": "Welcome to Maven 101\n\n\nWelcome to the Maven 101 training course. This course will teach you the basics of maven and how we use it.\n\n\nGoal\n\n\nThe goal of this course is to give you an overview over the most important topics when using maven.\nEvery task will deal with one specific aspect of maven.\nThese topics are:\n\n\n\n\nBasic project setup\n\n\nOverriding properties\n\n\nAdding dependencies\n\n\nModifying the build\n\n\n\n\nPrerequisites\n\n\nTo successfully complete this session you need to have the following software installed and up and running:\n\n\n\n\nMaven\n\n\nJava8\n\n\n\n\nInstructions\n\n\nFirst read the \ntheoretical introduction\n.\n\n\nFor each task in the upper menu\n\n\n\n\nTake a look in the specific task folder \n/tasks/task_XX\n\n\nModify the content of said folder to solve the task at hand\n\n\nExecute \nmvn clean verify -PtaskX\n in the \nroot\n of the checked out project\n\n\nReload the task page to check if the task has been completed.\n\n\n\n\nAlso you will find a couple of \n*.md\n files in the task directories. They are used to generate this website so just\nignore them.",
            "title": "Introduction"
        },
        {
            "location": "/index.html#welcome-to-maven-101",
            "text": "Welcome to the Maven 101 training course. This course will teach you the basics of maven and how we use it.",
            "title": "Welcome to Maven 101"
        },
        {
            "location": "/index.html#goal",
            "text": "The goal of this course is to give you an overview over the most important topics when using maven.\nEvery task will deal with one specific aspect of maven.\nThese topics are:   Basic project setup  Overriding properties  Adding dependencies  Modifying the build",
            "title": "Goal"
        },
        {
            "location": "/index.html#prerequisites",
            "text": "To successfully complete this session you need to have the following software installed and up and running:   Maven  Java8",
            "title": "Prerequisites"
        },
        {
            "location": "/index.html#instructions",
            "text": "First read the  theoretical introduction .  For each task in the upper menu   Take a look in the specific task folder  /tasks/task_XX  Modify the content of said folder to solve the task at hand  Execute  mvn clean verify -PtaskX  in the  root  of the checked out project  Reload the task page to check if the task has been completed.   Also you will find a couple of  *.md  files in the task directories. They are used to generate this website so just\nignore them.",
            "title": "Instructions"
        },
        {
            "location": "/theory/index.html",
            "text": "Theoretical introduction\n\n\nThis page will give you a short theoretical overview about maven.\nAs it is an Apache project there is extensive documentation available\nunder \nhttps://maven.apache.org/\n.\n\n\nWhat is a build tool?\n\n\nMaven is basically \"just another build tool\".\nBuild tools take care of the more tedious tasks of software development.\n\n\nDependency management\n\n\nIn former times you would download your dependencies yourself, extract them to your project and then modify the classpath manually to use them.\nBuild tools take care of this for you. You just specify the dependencies and the tool downloads and integrates them.\n\n\nTesting\n\n\nBuildtools also take care of your tests. As soon as you initiate a build the tool will run your tests\nfor you and then give you feedback if your tests succeeded. If not it will also prevent the creation of a build result\nso that you cannot ship a broken application by accident.\n\n\nDeployable artifacts\n\n\nThe tool will also give you a deployable artifact in the end. With this mechanism you can take the result of the build\nand ship it right away. This is essential for a continuous delivery pipeline.\n\n\nMaven specific details\n\n\nIdentifying artifacts\n\n\nMaven calls the result of a build an Artifact. This can be anything, from the standard jar over the documentation zip files\nup to binaries. The only thing that matters is that it is some file that can be identified.\n\n\nTo identify and share an artifact maven uses three distinct values.\n\n\n\n\nthe groupId\n\n\nthe artifactId\n\n\nthe version\n\n\n\n\ngroupId\n\n\nThe groupId is defining a group of artifacts like package names in Java. They also follow the same conventions of\nbackwards domains. If you want to build something for the Zalando Mentoring for example, the groupId might be\n\n\nde.zalando.mentoring\n\n\n\n\nartifactId\n\n\nThe artifactId serves the same function as a Java class name. It is a unique identifier within a group of artifacts.\nTo stick to the example from above a typical artifactId for the mentoring project could be\n\n\nmaven-101\n\n\n\n\nVersioning\n\n\nThe version is actually just a string. So in theory you could put whatever you want here. It is highly recommended\nthough to stick to a versioning scheme that is easily readable like \nsemantic versioning\n.\n\n\nImportant:\n\n\n\n\nVersions have to be unique on any given repository. To circumvent that you can append the String '-SNAPSHOT' to your version.\nThis will tell maven to treat the version as non unique.\n\n\nThis has implications though:\n\n\nReferencing a snapshot version as a dependency does not guarantee anything! Everything can change from one build to the next!\n\n\n\n\nStoring and sharing artifacts\n\n\nWe have seen the three identifiers of an artifact now. But how do they play together?\n\n\nAs written before the main reason for using a build tool is to get rid of downloading dependencies manually. To\nachieve this maven stores all artifacts in repositories. A repository is basically a server that can be accessed via\nHTTP. All artifacts are identified by the triplet described before. The groupId describes the folder, the artifactId\nthe filename and the version the version suffix of the desired artifact.\n\n\nThe interesting part about this is that the maven server makes sure that versions are unique. If you push\n\nde.zalando.mentoring:maven-101:0.0.1\n to a repository this version is taken and can not be overwritten. This guarantees that\neveryone who references this artifact as a dependency will receive the exact same file every single time. Therefore\nmaven is really reliable (unless the repository is shut down of course :) ).\n\n\nOf course there are scenarios where this behaviour is not desired. To circumvent the uniqueness of an artifact you can\nappend \n-SNAPSHOT\n to your version. This removes the unique constraint and the artifact can be overwritten. This\nshould be handled with care as a SNAPSHOT dependency can change drastically, possibly breaking contracts, on every\nsingle update!\n\n\nImportant:\n\n\n\n\nMaven uses a local cache in your home/.m2 directory. As this is a local directory which belongs to you, you can do\nwhatever you want there. If you issue a maven install into your local cache you can overwrite everything, breaking\nthe uniqueness of your artifact version and therefore potentially diverge your local dependencies from the one in the\n repo. This leads to interesting \"works on my machine\" situations that you want to avoid!\n\n\n\n\nMaven lifecycle\n\n\nIn the previous section we briefly mentioned \nmaven install\n. This section will explain the details behind this.\n\n\nEvery maven build follows the so called \nmaven lifecycle\n.\n\n\nTo understand the lifecycle we first have to define some words:\n\n\n\n\ngoal\n\n\nphase\n\n\n\n\nA \ngoal\n is basically a command that you can issue to maven or one of the plugins used.\n\n\nA \nphase\n is one \ngoal\n in the lifecycle; the lifecycle consists of many \nphases\n.\n\n\nThe full maven lifecycle looks like this:\n\n\n\n\nvalidate\n - validate that the project is correct and all necessary information is available\n\n\ncompile\n - compile the source code of the project\n\n\ntest\n - test the compiled source code using a suitable unit testing framework. These tests should not require the\n code be packaged or deployed\n\n\npackage\n - take the compiled code and package it in its distributable format, such as a JAR.\n\n\nintegration-test\n - process and deploy the package if necessary into an environment where integration tests can be run\n\n\nverify\n - run any checks to verify the package is valid and meets quality criteria\n\n\ninstall\n - install the package into the local repository, for use as a dependency in other projects locally\n\n\ndeploy\n - done in an integration or release environment, copies the final package to the remote repository for\nsharing with other developers and projects.\n\n\n\n\nOne additional command is the \nclean\n command which just deletes the target directory.\n\n\nThe important part about the lifecycle is that the goals depend on each other. If you issue the \nverify\n command for\nexample, maven will issue all commands up to \nverify\n automatically. Therefore you don't have to take care about the\nproject being compiled before you verify it. Maven will make sure that you are always doing the intuitive thing.\n\n\nAlso you can chain commands together. E.g. you can type \nmvn clean verify\n which will first delete all remaining\nfiles from the previous builds and then build and verify the current state of the project.\n\n\nConvention over configuration\n\n\nOne important aspect of maven is the principle of \nConvention over Configuration\n.\nThis basically boils down to \"There is a default for everything\". Technically this is implemented in a way similar to Java.\nEvery maven configuration inherits from an invisible super parent (unless a specific parent is specified. See (TODO-\n parents) for details).\nIn your actual pom file your basically just overwrite and extend the default settings.\n\n\nBut this principle is not just limited to the configuration. It also affects the folder structure.\n\n\nThe standard folder structure of a maven project looks like this:\n\n\nproject-home\n  |--- src\n  |     |--- main\n  |     |     |--- java\n  |     |     |--- resources\n  |     |--- test\n  |     |     |--- java\n  |     |     |--- resources\n  |--- target\n  |--- pom.xml\n\n\n\n\nYour \nproject\n folder only contains the pom file and whatever files your IDE needs.\nThe \nsrc\n folder contains your project (splitted into \nmain\n for the actual application and \ntest\n for\nall test related soruces) and the \ntarget\n folder contains everything that is produced by the build\n(including intermediate products).",
            "title": "Theory"
        },
        {
            "location": "/theory/index.html#theoretical-introduction",
            "text": "This page will give you a short theoretical overview about maven.\nAs it is an Apache project there is extensive documentation available\nunder  https://maven.apache.org/ .",
            "title": "Theoretical introduction"
        },
        {
            "location": "/theory/index.html#what-is-a-build-tool",
            "text": "Maven is basically \"just another build tool\".\nBuild tools take care of the more tedious tasks of software development.  Dependency management  In former times you would download your dependencies yourself, extract them to your project and then modify the classpath manually to use them.\nBuild tools take care of this for you. You just specify the dependencies and the tool downloads and integrates them.  Testing  Buildtools also take care of your tests. As soon as you initiate a build the tool will run your tests\nfor you and then give you feedback if your tests succeeded. If not it will also prevent the creation of a build result\nso that you cannot ship a broken application by accident.  Deployable artifacts  The tool will also give you a deployable artifact in the end. With this mechanism you can take the result of the build\nand ship it right away. This is essential for a continuous delivery pipeline.",
            "title": "What is a build tool?"
        },
        {
            "location": "/theory/index.html#maven-specific-details",
            "text": "Identifying artifacts  Maven calls the result of a build an Artifact. This can be anything, from the standard jar over the documentation zip files\nup to binaries. The only thing that matters is that it is some file that can be identified.  To identify and share an artifact maven uses three distinct values.   the groupId  the artifactId  the version   groupId  The groupId is defining a group of artifacts like package names in Java. They also follow the same conventions of\nbackwards domains. If you want to build something for the Zalando Mentoring for example, the groupId might be  de.zalando.mentoring  artifactId  The artifactId serves the same function as a Java class name. It is a unique identifier within a group of artifacts.\nTo stick to the example from above a typical artifactId for the mentoring project could be  maven-101  Versioning  The version is actually just a string. So in theory you could put whatever you want here. It is highly recommended\nthough to stick to a versioning scheme that is easily readable like  semantic versioning .  Important:   Versions have to be unique on any given repository. To circumvent that you can append the String '-SNAPSHOT' to your version.\nThis will tell maven to treat the version as non unique.  This has implications though:  Referencing a snapshot version as a dependency does not guarantee anything! Everything can change from one build to the next!   Storing and sharing artifacts  We have seen the three identifiers of an artifact now. But how do they play together?  As written before the main reason for using a build tool is to get rid of downloading dependencies manually. To\nachieve this maven stores all artifacts in repositories. A repository is basically a server that can be accessed via\nHTTP. All artifacts are identified by the triplet described before. The groupId describes the folder, the artifactId\nthe filename and the version the version suffix of the desired artifact.  The interesting part about this is that the maven server makes sure that versions are unique. If you push de.zalando.mentoring:maven-101:0.0.1  to a repository this version is taken and can not be overwritten. This guarantees that\neveryone who references this artifact as a dependency will receive the exact same file every single time. Therefore\nmaven is really reliable (unless the repository is shut down of course :) ).  Of course there are scenarios where this behaviour is not desired. To circumvent the uniqueness of an artifact you can\nappend  -SNAPSHOT  to your version. This removes the unique constraint and the artifact can be overwritten. This\nshould be handled with care as a SNAPSHOT dependency can change drastically, possibly breaking contracts, on every\nsingle update!  Important:   Maven uses a local cache in your home/.m2 directory. As this is a local directory which belongs to you, you can do\nwhatever you want there. If you issue a maven install into your local cache you can overwrite everything, breaking\nthe uniqueness of your artifact version and therefore potentially diverge your local dependencies from the one in the\n repo. This leads to interesting \"works on my machine\" situations that you want to avoid!   Maven lifecycle  In the previous section we briefly mentioned  maven install . This section will explain the details behind this.  Every maven build follows the so called  maven lifecycle .  To understand the lifecycle we first have to define some words:   goal  phase   A  goal  is basically a command that you can issue to maven or one of the plugins used.  A  phase  is one  goal  in the lifecycle; the lifecycle consists of many  phases .  The full maven lifecycle looks like this:   validate  - validate that the project is correct and all necessary information is available  compile  - compile the source code of the project  test  - test the compiled source code using a suitable unit testing framework. These tests should not require the\n code be packaged or deployed  package  - take the compiled code and package it in its distributable format, such as a JAR.  integration-test  - process and deploy the package if necessary into an environment where integration tests can be run  verify  - run any checks to verify the package is valid and meets quality criteria  install  - install the package into the local repository, for use as a dependency in other projects locally  deploy  - done in an integration or release environment, copies the final package to the remote repository for\nsharing with other developers and projects.   One additional command is the  clean  command which just deletes the target directory.  The important part about the lifecycle is that the goals depend on each other. If you issue the  verify  command for\nexample, maven will issue all commands up to  verify  automatically. Therefore you don't have to take care about the\nproject being compiled before you verify it. Maven will make sure that you are always doing the intuitive thing.  Also you can chain commands together. E.g. you can type  mvn clean verify  which will first delete all remaining\nfiles from the previous builds and then build and verify the current state of the project.  Convention over configuration  One important aspect of maven is the principle of  Convention over Configuration .\nThis basically boils down to \"There is a default for everything\". Technically this is implemented in a way similar to Java.\nEvery maven configuration inherits from an invisible super parent (unless a specific parent is specified. See (TODO-  parents) for details).\nIn your actual pom file your basically just overwrite and extend the default settings.  But this principle is not just limited to the configuration. It also affects the folder structure.  The standard folder structure of a maven project looks like this:  project-home\n  |--- src\n  |     |--- main\n  |     |     |--- java\n  |     |     |--- resources\n  |     |--- test\n  |     |     |--- java\n  |     |     |--- resources\n  |--- target\n  |--- pom.xml  Your  project  folder only contains the pom file and whatever files your IDE needs.\nThe  src  folder contains your project (splitted into  main  for the actual application and  test  for\nall test related soruces) and the  target  folder contains everything that is produced by the build\n(including intermediate products).",
            "title": "Maven specific details"
        },
        {
            "location": "/01_basic_setup/basic_setup/index.html",
            "text": "Basic project setup\n\n\nThe first task is to start from almost nothing and make the project buildable.\n\n\nPlease take a look in the folder \ntasks/01_basic_setup\n. You will find a \npom.xml\n which is exactly what you will find on the\ninternet if you search for an example of a pom file.\n\n\nThe task now is to make the project buildable.\n\n\nIf you are ready execute \nmvn clean verify -Ptask1\n in the root of the project and reload this page.",
            "title": "Basic Project Setup"
        },
        {
            "location": "/01_basic_setup/basic_setup/index.html#basic-project-setup",
            "text": "The first task is to start from almost nothing and make the project buildable.  Please take a look in the folder  tasks/01_basic_setup . You will find a  pom.xml  which is exactly what you will find on the\ninternet if you search for an example of a pom file.  The task now is to make the project buildable.  If you are ready execute  mvn clean verify -Ptask1  in the root of the project and reload this page.",
            "title": "Basic project setup"
        },
        {
            "location": "/02_dependencies/dependencies/index.html",
            "text": "Adding Dependencies\n\n\nOne of the core features of Maven is to do dependency management for you. In former times you would\nhave to download all your dependencies yourself, copy them into your project and then modify the classpath\nto actually be able to use them. Maven will take care of all of this for you.\n\n\nIn the folder \n02_dependencies\n you will find a pom file that just describes a basic project.\nTo make it compile you will need to add a dependency to the \nguava library\n.\n\n\nIf you are ready execute \nmvn clean verify -Ptask2\n in the root of the project and reload this page.\n\n\nFinding dependency definitions\n\n\nTo add a dependency to your project you need to know the three values for \ngroupId\n, \nartifactId\n and \nversion\n that\nyou want to use. Usually there are two main ways to find out about these values:\n\n\nThe project website.\n\n\nIn the case of guava for example the readme actually states these information.\n\n\nThe maven central index.\n\n\nYou can always navigate to \nmaven central\n and then search for the artifact you are looking\nfor. In our case this would be \ngoogle guava\n. After selecting a version that suits your needs the website will\nshow you the dependency information to add to your project.",
            "title": "Adding Dependencies"
        },
        {
            "location": "/02_dependencies/dependencies/index.html#adding-dependencies",
            "text": "One of the core features of Maven is to do dependency management for you. In former times you would\nhave to download all your dependencies yourself, copy them into your project and then modify the classpath\nto actually be able to use them. Maven will take care of all of this for you.  In the folder  02_dependencies  you will find a pom file that just describes a basic project.\nTo make it compile you will need to add a dependency to the  guava library .  If you are ready execute  mvn clean verify -Ptask2  in the root of the project and reload this page.",
            "title": "Adding Dependencies"
        },
        {
            "location": "/02_dependencies/dependencies/index.html#finding-dependency-definitions",
            "text": "To add a dependency to your project you need to know the three values for  groupId ,  artifactId  and  version  that\nyou want to use. Usually there are two main ways to find out about these values:  The project website.  In the case of guava for example the readme actually states these information.  The maven central index.  You can always navigate to  maven central  and then search for the artifact you are looking\nfor. In our case this would be  google guava . After selecting a version that suits your needs the website will\nshow you the dependency information to add to your project.",
            "title": "Finding dependency definitions"
        },
        {
            "location": "/03_properties/properties/index.html",
            "text": "Properties and Defaults\n\n\nAs described \nearlier\n Maven has defaults for everything.\n\n\nIf you try to build this project by executing \nmvn clean verify -Ptask3\n you will notice that these defaults are\nsometimes not the best.\n\n\nLuckily that is easy to fix. As explained in the theoretical background you can overwrite the properties from\nthe parent and the defaults by specifying them again. The way to do it is described\n\nhere\n.\n\n\nThe properties in question are \nmaven.compiler.source\n and \nmaven.compiler.target\n which tell the maven\nsystem which Java version to assume for the source code and the output jar.\n\n\nThe task now is again to make the project build.",
            "title": "Properties and Defaults"
        },
        {
            "location": "/03_properties/properties/index.html#properties-and-defaults",
            "text": "As described  earlier  Maven has defaults for everything.  If you try to build this project by executing  mvn clean verify -Ptask3  you will notice that these defaults are\nsometimes not the best.  Luckily that is easy to fix. As explained in the theoretical background you can overwrite the properties from\nthe parent and the defaults by specifying them again. The way to do it is described here .  The properties in question are  maven.compiler.source  and  maven.compiler.target  which tell the maven\nsystem which Java version to assume for the source code and the output jar.  The task now is again to make the project build.",
            "title": "Properties and Defaults"
        },
        {
            "location": "/04_tests/tests/index.html",
            "text": "Tests\n\n\nOne of the main tasks of a build system is to ensure that all your testa are passing. If we go back to the\n\nMaven lifecycle\n you can see two phases covering tests:\n\n\n\n\ntest\n\n\nintegration-test\n\n\n\n\nBy default the test phase will run your JUnit unit tests (if there is a JUnit dependency in your project).\nThe \nintegration-test\n phase is used by plugins like the \nfailsafe-plugin\n to run more complex tests that\nusually involve deploying the artifact to an application server or starting up a database.\n\n\nThe interesting aspect of this is that your build will fail if your tests fail, thus preventing you from\nreceiving an artifact in the end. This way you cannot (even by accident or thorugh an automated pipeline) deploy\nsomething that has failing tests. \nThis of course only works if your tests cover all your use cases ;)\n\n\nAgain, the task is to make the project build work using \nmvn clean verify -Ptask4\n.\nAlso verify that you see why it is failing in the first place and also check the target folder\nto see what it looks like when the build stops at some point.\n\n\nFurther reading\n\n\nIf you want to enhance your knowledge on this topic we highly recommend to start reading about the\n\nMaven surefire plugin\n and the\n\nMaven failsafe plugin\n as they are the basis for\nall extended testing.",
            "title": "Tests"
        },
        {
            "location": "/04_tests/tests/index.html#tests",
            "text": "One of the main tasks of a build system is to ensure that all your testa are passing. If we go back to the Maven lifecycle  you can see two phases covering tests:   test  integration-test   By default the test phase will run your JUnit unit tests (if there is a JUnit dependency in your project).\nThe  integration-test  phase is used by plugins like the  failsafe-plugin  to run more complex tests that\nusually involve deploying the artifact to an application server or starting up a database.  The interesting aspect of this is that your build will fail if your tests fail, thus preventing you from\nreceiving an artifact in the end. This way you cannot (even by accident or thorugh an automated pipeline) deploy\nsomething that has failing tests.  This of course only works if your tests cover all your use cases ;)  Again, the task is to make the project build work using  mvn clean verify -Ptask4 .\nAlso verify that you see why it is failing in the first place and also check the target folder\nto see what it looks like when the build stops at some point.",
            "title": "Tests"
        },
        {
            "location": "/04_tests/tests/index.html#further-reading",
            "text": "If you want to enhance your knowledge on this topic we highly recommend to start reading about the Maven surefire plugin  and the Maven failsafe plugin  as they are the basis for\nall extended testing.",
            "title": "Further reading"
        },
        {
            "location": "/05_plugins/plugins/index.html",
            "text": "Plugins\n\n\nSo far we have seen how to overwrite properties, add dependencies and how the integration with tests works.\nOne other large aspect of maven is the versatility of the ecosystem. For the most basic java projects the knowledge\nyou accumulated so far might be sufficient. But most of our projects are not basic... To build them we have to\n\n\nModify the build\n\n\nTo change or extend the way maven is building your project you can add plugins to the build. Plugins are also\nidentified like artifacts (groupId, artifactId, version) but instead of just adding code to your classpath\nmaven will execute them according to their configuration.\n\n\nPlugin categories\n\n\nConfiguration wise plugins split into two groups.\n\n\nAdding capabilities\n\n\nAdding capabilities is dead easy, just add the plugin to the build tag. The prime example here is the\n\nTomcat Maven plugin\n. It is used to add a tomcat webserver to your\nproject that you can fire up and deploy your application to with just one command.\n\n\nIf you just add this plugin to your build like this\n\n\nbuild\n\n  \nplugins\n\n    \nplugin\n\n      \ngroupId\norg.apache.tomcat.maven\n/groupId\n\n      \nartifactId\ntomcat6-maven-plugin\n/artifactId\n\n      \nversion\n2.3-SNAPSHOT\n/version\n\n    \n/plugin\n\n  \n/plugins\n\n\n/build\n\n\n\n\n\nIt will do nothing on its own but give you access to the plugin specific goals like \nmvn tomcat:run-war\n.\n\n\nChanging the behaviour of the build\n\n\nThe second category of plugins are the ones that actually modify the way the build behaves. The prime example\nfor this category is the \nMaven failsafe plugin\n which\nis used to run your integration test. The configuration for using this plugin looks like this:\n\n\nbuild\n\n  \nplugins\n\n    \nplugin\n\n      \ngroupId\norg.apache.maven.plugins\n/groupId\n\n      \nartifactId\nmaven-failsafe-plugin\n/artifactId\n\n      \nversion\n2.19\n/version\n\n      \nexecutions\n\n        \nexecution\n\n          \nphase\nintegration-test\n\n          \ngoals\n\n            \ngoal\nverify\n/goal\n\n          \n/goals\n\n        \n/execution\n\n      \n/executions\n\n    \n/plugin\n\n  \n/plugins\n\n\n/build\n\n\n\n\n\nThis configuration binds to the \nintegration-test\n phase and tells maven to call the \nverify\n goal of the plugin.\nWith this mechanism you can now change all kinds of things, be it running SQL scripts against databases, compile C code,\ngenerate documentation websites etc.\n\n\nTask\n\n\nTo complete this task you will have to make the same change as in the \nproperties\n task;\nchange the java version to java 8. But this time it should be done by adding the\n\nMaven Compiler plugin\n. If you are ready just run\n\nmvn clean verify -Ptask5\n as always.",
            "title": "Plugins"
        },
        {
            "location": "/05_plugins/plugins/index.html#plugins",
            "text": "So far we have seen how to overwrite properties, add dependencies and how the integration with tests works.\nOne other large aspect of maven is the versatility of the ecosystem. For the most basic java projects the knowledge\nyou accumulated so far might be sufficient. But most of our projects are not basic... To build them we have to",
            "title": "Plugins"
        },
        {
            "location": "/05_plugins/plugins/index.html#modify-the-build",
            "text": "To change or extend the way maven is building your project you can add plugins to the build. Plugins are also\nidentified like artifacts (groupId, artifactId, version) but instead of just adding code to your classpath\nmaven will execute them according to their configuration.",
            "title": "Modify the build"
        },
        {
            "location": "/05_plugins/plugins/index.html#plugin-categories",
            "text": "Configuration wise plugins split into two groups.  Adding capabilities  Adding capabilities is dead easy, just add the plugin to the build tag. The prime example here is the Tomcat Maven plugin . It is used to add a tomcat webserver to your\nproject that you can fire up and deploy your application to with just one command.  If you just add this plugin to your build like this  build \n   plugins \n     plugin \n       groupId org.apache.tomcat.maven /groupId \n       artifactId tomcat6-maven-plugin /artifactId \n       version 2.3-SNAPSHOT /version \n     /plugin \n   /plugins  /build   It will do nothing on its own but give you access to the plugin specific goals like  mvn tomcat:run-war .  Changing the behaviour of the build  The second category of plugins are the ones that actually modify the way the build behaves. The prime example\nfor this category is the  Maven failsafe plugin  which\nis used to run your integration test. The configuration for using this plugin looks like this:  build \n   plugins \n     plugin \n       groupId org.apache.maven.plugins /groupId \n       artifactId maven-failsafe-plugin /artifactId \n       version 2.19 /version \n       executions \n         execution \n           phase integration-test \n           goals \n             goal verify /goal \n           /goals \n         /execution \n       /executions \n     /plugin \n   /plugins  /build   This configuration binds to the  integration-test  phase and tells maven to call the  verify  goal of the plugin.\nWith this mechanism you can now change all kinds of things, be it running SQL scripts against databases, compile C code,\ngenerate documentation websites etc.",
            "title": "Plugin categories"
        },
        {
            "location": "/05_plugins/plugins/index.html#task",
            "text": "To complete this task you will have to make the same change as in the  properties  task;\nchange the java version to java 8. But this time it should be done by adding the Maven Compiler plugin . If you are ready just run mvn clean verify -Ptask5  as always.",
            "title": "Task"
        },
        {
            "location": "/06_webapp/webapp/index.html",
            "text": "Webapps\n\n\nMost of the applications we are building here are deployed webapps. If you provide internal websites or just\nREST endpoints, you will need a webserver of some kind. To transoform a maven project into a web application\nis really easy. Just perform the following steps and then run \nmvn clean verify -Ptask6\n.\n\n\nPackaging\n\n\nFirst you have to overwrite the \npackaging\n attribute of your project. The default is \njar\n but if you switch it\nto \nwar\n maven will produce a webapp package instead. The layout of the war archive is also changed according to\nthe standard (dependencies as jars in a lib folder, etc.).\n\n\nactual webapp\n\n\nOf course you also need a real webapp to deploy. You will find a small hello world website in the task folder.\n\n\nThe important part here is the folder structure (again convention over configuration). You will find the page\nin the webapp folder.\n\n\nproject-home\n  |--- src\n        |--- main\n              |--- java\n              |--- webapp\n                    |--- WEB-INF\n                    |     |--- web.xml\n                    |--- index.html\n\n\n\n\nTest the app\n\n\nTo test the application you would now have to build and run it. In former times you would have produced the\npackaged app, copy it to your application server and then start it. Thanks to maven this is no longer necessary.\nAs described in the plugins section please add the \nTomcat Maven plugin\n\nto the project and run the app with \nmvn clean tomcat:run-war\n from the task folder. Then navigate to \nhttp://localhost:8080/maven101-task6/\n\nand check if the app is showing correctly.\nIf it does run \nmvn clean verify -Ptask6\n from the root again to mark the task as completed.",
            "title": "Webapp"
        },
        {
            "location": "/06_webapp/webapp/index.html#webapps",
            "text": "Most of the applications we are building here are deployed webapps. If you provide internal websites or just\nREST endpoints, you will need a webserver of some kind. To transoform a maven project into a web application\nis really easy. Just perform the following steps and then run  mvn clean verify -Ptask6 .",
            "title": "Webapps"
        },
        {
            "location": "/06_webapp/webapp/index.html#packaging",
            "text": "First you have to overwrite the  packaging  attribute of your project. The default is  jar  but if you switch it\nto  war  maven will produce a webapp package instead. The layout of the war archive is also changed according to\nthe standard (dependencies as jars in a lib folder, etc.).",
            "title": "Packaging"
        },
        {
            "location": "/06_webapp/webapp/index.html#actual-webapp",
            "text": "Of course you also need a real webapp to deploy. You will find a small hello world website in the task folder.  The important part here is the folder structure (again convention over configuration). You will find the page\nin the webapp folder.  project-home\n  |--- src\n        |--- main\n              |--- java\n              |--- webapp\n                    |--- WEB-INF\n                    |     |--- web.xml\n                    |--- index.html",
            "title": "actual webapp"
        },
        {
            "location": "/06_webapp/webapp/index.html#test-the-app",
            "text": "To test the application you would now have to build and run it. In former times you would have produced the\npackaged app, copy it to your application server and then start it. Thanks to maven this is no longer necessary.\nAs described in the plugins section please add the  Tomcat Maven plugin \nto the project and run the app with  mvn clean tomcat:run-war  from the task folder. Then navigate to  http://localhost:8080/maven101-task6/ \nand check if the app is showing correctly.\nIf it does run  mvn clean verify -Ptask6  from the root again to mark the task as completed.",
            "title": "Test the app"
        }
    ]
}
{
    "docs": [
        {
            "location": "/index.html",
            "text": "Welcome to Maven 101\n\n\nWelcome to the Maven 101 training course. This course will teach you the basics of maven and how we use it.\n\n\nGoal\n\n\nThe goal of this course is to give you an overview over the most important topics when using maven.\nThese topics are:\n\n\n\n\nBasic project setup\n\n\nOverriding properties\n\n\nAdding dependencies\n\n\nModifying the build\n\n\n\n\nPrerequisites\n\n\nTo successfully complete this session you need to have the following software installed and up and running:\n\n\n\n\nMaven\n\n\nJava8\n\n\n\n\nInstructions\n\n\nTo complete this session please read the \ntheoretical introduction\n first.\nAfter doing so you can find the description of the individual tasks in the tasks menu at the top.\n\n\nEvery single task will deal with one specific aspect of maven.\nIn the repository you checked out there is a folder named \ntasks\n that contains folders for the individual tasks\nthemselves.\nIf you think the task is completed just run a maven clean verify -PtaskX in the root of the project.\nIf everything goes well the corresponding task page (as well as the maven build) will give you feedback.\n\n\nAlso you will find a couple of \n*.md\n files in the task directories. They are used to generate this website so just\nignore them.",
            "title": "Introduction"
        },
        {
            "location": "/index.html#welcome-to-maven-101",
            "text": "Welcome to the Maven 101 training course. This course will teach you the basics of maven and how we use it.",
            "title": "Welcome to Maven 101"
        },
        {
            "location": "/index.html#goal",
            "text": "The goal of this course is to give you an overview over the most important topics when using maven.\nThese topics are:   Basic project setup  Overriding properties  Adding dependencies  Modifying the build",
            "title": "Goal"
        },
        {
            "location": "/index.html#prerequisites",
            "text": "To successfully complete this session you need to have the following software installed and up and running:   Maven  Java8",
            "title": "Prerequisites"
        },
        {
            "location": "/index.html#instructions",
            "text": "To complete this session please read the  theoretical introduction  first.\nAfter doing so you can find the description of the individual tasks in the tasks menu at the top.  Every single task will deal with one specific aspect of maven.\nIn the repository you checked out there is a folder named  tasks  that contains folders for the individual tasks\nthemselves.\nIf you think the task is completed just run a maven clean verify -PtaskX in the root of the project.\nIf everything goes well the corresponding task page (as well as the maven build) will give you feedback.  Also you will find a couple of  *.md  files in the task directories. They are used to generate this website so just\nignore them.",
            "title": "Instructions"
        },
        {
            "location": "/theory/index.html",
            "text": "Theoretical introduction\n\n\nThis page will give you a short theoretical overview about maven.\nAs it is an Apache project there is extensive documentation available\nunder \nhttps://maven.apache.org/\n.\n\n\nWhat is a build tool?\n\n\nMaven is basically \"just another build tool\".\nBuild tools take care of the more tedious tasks of software development.\n\n\nDependency management\n\n\nIn former times you would download your dependencies yourself, extract them to your project and then modify the classpath manually to use them.\nBuild tools take care of this for you. You just specify the dependencies and the tool downloads and integrates them.\n\n\nTesting\n\n\nBuildtools also take care of your tests. As soon as you initiate a build the tool will run your tests\nfor you and then give you feedback if your tests succeeded. If not it will also prevent the creation of a build result\nso that you cannot ship a broken application by accident.\n\n\nDeployable artifacts\n\n\nThe tool will also give you a deployable artifact in the end. With this mechanism you can take the result of the build\nand ship it right away. This is essential for a continuous delivery pipeline.\n\n\nMaven specific details\n\n\nIdentifying artifacts\n\n\nMaven calls the result of a build an Artifact. This can be anything, from the standard jar over the documentation zip files\nup to binaries. The only thing that matters is that it is some file that can be identified.\n\n\nTo identify and share an artifact maven uses three distinct values.\n\n\n\n\nthe groupId\n\n\nthe artifactId\n\n\nthe version\n\n\n\n\ngroupId\n\n\nThe groupId is defining a group of artifacts like package names in Java. They also follow the same conventions of\nbackwards domains. If you want to build something for the Zalando Mentoring for example, the groupId might be\n\n\nde.zalando.mentoring\n\n\n\n\nartifactId\n\n\nThe artifactId serves the same function as a Java class name. It is a unique identifier within a group of artifacts.\nTo stick to the example from above a typical artifactId for the mentoring project could be\n\n\nmaven-101\n\n\n\n\nVersioning\n\n\nThe version is actually just a string. So in theory you could put whatever you want here. It is highly recommended\nthough to stick to a versioning scheme that is easily readable like \nsemantic versioning\n.\n\n\nImportant:\n\n\n\n\nVersions have to be unique on any given repository. To circumvent that you can append the String '-SNAPSHOT' to your version.\nThis will tell maven to treat the version as non unique.\n\n\nThis has implications though:\n\n\nReferencing a snapshot version as a dependency does not guarantee anything! Everything can change from one build to the next!\n\n\n\n\nStoring and sharing artifacts\n\n\nWe have seen the three identifiers of an artifact now. But how do they play together?\n\n\nAs written before the main reason for using a build tool is to get rid of downloading dependencies manually. To\nachieve this maven stores all artifacts in repositories. A repository is basically a server that can be accessed via\nHTTP. All artifacts are identified by the triplet described before. The groupId describes the folder, the artifactId\nthe filename and the version the version suffix of the desired artifact.\n\n\nThe interesting part about this is that the maven server makes sure that versions are unique. If you push\n\nde.zalando.mentoring:maven-101:0.0.1\n to a repository this version is taken and can not be overwritten. This guarantees that\neveryone who references this artifact as a dependency will receive the exact same file every single time. Therefore\nmaven is really reliable (unless the repository is shut down of course :) ).\n\n\nOf course there are scenarios where this behaviour is not desired. To circumvent the uniqueness of an artifact you can\nappend \n-SNAPSHOT\n to your version. This removes the unique constraint and the artifact can be overwritten. This\nshould be handled with care as a SNAPSHOT dependency can change drastically, possibly breaking contracts, on every\nsingle update!\n\n\nImportant:\n\n\n\n\nMaven uses a local cache in your home/.m2 directory. As this is a local directory which belongs to you, you can do\nwhatever you want there. If you issue a maven install into your local cache you can overwrite everything, breaking\nthe uniqueness of your artifact version and therefore potentially diverge your local dependencies from the one in the\n repo. This leads to interesting \"works on my machine\" situations that you want to avoid!\n\n\n\n\nMaven lifecycle\n\n\nIn the previous section we briefly mentioned \nmaven install\n. This section will explain the details behind this.\n\n\nEvery maven build follows the so called \nmaven lifecycle\n.\n\n\nTo understand the lifecycle we first have to define some words:\n\n\n\n\ngoal\n\n\nphase\n\n\n\n\nA \ngoal\n is basically a command that you can issue to maven or one of the plugins used.\n\n\nA \nphase\n is one \ngoal\n in the lifecycle; the lifecycle consists of many \nphases\n.\n\n\nThe full maven lifecycle looks like this:\n\n\n\n\nvalidate\n - validate that the project is correct and all necessary information is available\n\n\ncompile\n - compile the source code of the project\n\n\ntest\n - test the compiled source code using a suitable unit testing framework. These tests should not require the\n code be packaged or deployed\n\n\npackage\n - take the compiled code and package it in its distributable format, such as a JAR.\n\n\nintegration-test\n - process and deploy the package if necessary into an environment where integration tests can be run\n\n\nverify\n - run any checks to verify the package is valid and meets quality criteria\n\n\ninstall\n - install the package into the local repository, for use as a dependency in other projects locally\n\n\ndeploy\n - done in an integration or release environment, copies the final package to the remote repository for\nsharing with other developers and projects.\n\n\n\n\nOne additional command is the \nclean\n command which just deletes the target directory.\n\n\nThe important part about the lifecycle is that the goals depend on each other. If you issue the \nverify\n command for\nexample, maven will issue all commands up to \nverify\n automatically. Therefore you don't have to take care about the\nproject being compiled before you verify it. Maven will make sure that you are always doing the intuitive thing.\n\n\nAlso you can chain commands together. E.g. you can type \nmvn clean verify\n which will first delete all remaining\nfiles from the previous builds and then build and verify the current state of the project.\n\n\nConvention over configuration\n\n\nOne important aspect of maven is the principle of \nConvention over Configuration\n.\nThis basically boils down to \"There is a default for everything\". Technically this is implemented in a way similar to Java.\nEvery maven configuration inherits from an invisible super parent (unless a specific parent is specified. See (TODO-\n parents) for details).\nIn your actual pom file your basically just overwrite and extend the default settings.\n\n\nBut this principle is not just limited to the configuration. It also affects the folder structure.\n\n\nThe standard folder structure of a maven project looks like this:\n\n\nproject-home\n  |--- src\n  |     |--- main\n  |     |     |--- java\n  |     |     |--- resources\n  |     |--- test\n  |     |     |--- java\n  |     |     |--- resources\n  |--- target\n  |--- pom.xml\n\n\n\n\nYour \nproject\n folder only contains the pom file and whatever files your IDE needs.\nThe \nsrc\n folder contains your project (splitted into \nmain\n for the actual application and \ntest\n for\nall test related soruces) and the \ntarget\n folder contains everything that is produced by the build\n(including intermediate products).",
            "title": "Theory"
        },
        {
            "location": "/theory/index.html#theoretical-introduction",
            "text": "This page will give you a short theoretical overview about maven.\nAs it is an Apache project there is extensive documentation available\nunder  https://maven.apache.org/ .",
            "title": "Theoretical introduction"
        },
        {
            "location": "/theory/index.html#what-is-a-build-tool",
            "text": "Maven is basically \"just another build tool\".\nBuild tools take care of the more tedious tasks of software development.  Dependency management  In former times you would download your dependencies yourself, extract them to your project and then modify the classpath manually to use them.\nBuild tools take care of this for you. You just specify the dependencies and the tool downloads and integrates them.  Testing  Buildtools also take care of your tests. As soon as you initiate a build the tool will run your tests\nfor you and then give you feedback if your tests succeeded. If not it will also prevent the creation of a build result\nso that you cannot ship a broken application by accident.  Deployable artifacts  The tool will also give you a deployable artifact in the end. With this mechanism you can take the result of the build\nand ship it right away. This is essential for a continuous delivery pipeline.",
            "title": "What is a build tool?"
        },
        {
            "location": "/theory/index.html#maven-specific-details",
            "text": "Identifying artifacts  Maven calls the result of a build an Artifact. This can be anything, from the standard jar over the documentation zip files\nup to binaries. The only thing that matters is that it is some file that can be identified.  To identify and share an artifact maven uses three distinct values.   the groupId  the artifactId  the version   groupId  The groupId is defining a group of artifacts like package names in Java. They also follow the same conventions of\nbackwards domains. If you want to build something for the Zalando Mentoring for example, the groupId might be  de.zalando.mentoring  artifactId  The artifactId serves the same function as a Java class name. It is a unique identifier within a group of artifacts.\nTo stick to the example from above a typical artifactId for the mentoring project could be  maven-101  Versioning  The version is actually just a string. So in theory you could put whatever you want here. It is highly recommended\nthough to stick to a versioning scheme that is easily readable like  semantic versioning .  Important:   Versions have to be unique on any given repository. To circumvent that you can append the String '-SNAPSHOT' to your version.\nThis will tell maven to treat the version as non unique.  This has implications though:  Referencing a snapshot version as a dependency does not guarantee anything! Everything can change from one build to the next!   Storing and sharing artifacts  We have seen the three identifiers of an artifact now. But how do they play together?  As written before the main reason for using a build tool is to get rid of downloading dependencies manually. To\nachieve this maven stores all artifacts in repositories. A repository is basically a server that can be accessed via\nHTTP. All artifacts are identified by the triplet described before. The groupId describes the folder, the artifactId\nthe filename and the version the version suffix of the desired artifact.  The interesting part about this is that the maven server makes sure that versions are unique. If you push de.zalando.mentoring:maven-101:0.0.1  to a repository this version is taken and can not be overwritten. This guarantees that\neveryone who references this artifact as a dependency will receive the exact same file every single time. Therefore\nmaven is really reliable (unless the repository is shut down of course :) ).  Of course there are scenarios where this behaviour is not desired. To circumvent the uniqueness of an artifact you can\nappend  -SNAPSHOT  to your version. This removes the unique constraint and the artifact can be overwritten. This\nshould be handled with care as a SNAPSHOT dependency can change drastically, possibly breaking contracts, on every\nsingle update!  Important:   Maven uses a local cache in your home/.m2 directory. As this is a local directory which belongs to you, you can do\nwhatever you want there. If you issue a maven install into your local cache you can overwrite everything, breaking\nthe uniqueness of your artifact version and therefore potentially diverge your local dependencies from the one in the\n repo. This leads to interesting \"works on my machine\" situations that you want to avoid!   Maven lifecycle  In the previous section we briefly mentioned  maven install . This section will explain the details behind this.  Every maven build follows the so called  maven lifecycle .  To understand the lifecycle we first have to define some words:   goal  phase   A  goal  is basically a command that you can issue to maven or one of the plugins used.  A  phase  is one  goal  in the lifecycle; the lifecycle consists of many  phases .  The full maven lifecycle looks like this:   validate  - validate that the project is correct and all necessary information is available  compile  - compile the source code of the project  test  - test the compiled source code using a suitable unit testing framework. These tests should not require the\n code be packaged or deployed  package  - take the compiled code and package it in its distributable format, such as a JAR.  integration-test  - process and deploy the package if necessary into an environment where integration tests can be run  verify  - run any checks to verify the package is valid and meets quality criteria  install  - install the package into the local repository, for use as a dependency in other projects locally  deploy  - done in an integration or release environment, copies the final package to the remote repository for\nsharing with other developers and projects.   One additional command is the  clean  command which just deletes the target directory.  The important part about the lifecycle is that the goals depend on each other. If you issue the  verify  command for\nexample, maven will issue all commands up to  verify  automatically. Therefore you don't have to take care about the\nproject being compiled before you verify it. Maven will make sure that you are always doing the intuitive thing.  Also you can chain commands together. E.g. you can type  mvn clean verify  which will first delete all remaining\nfiles from the previous builds and then build and verify the current state of the project.  Convention over configuration  One important aspect of maven is the principle of  Convention over Configuration .\nThis basically boils down to \"There is a default for everything\". Technically this is implemented in a way similar to Java.\nEvery maven configuration inherits from an invisible super parent (unless a specific parent is specified. See (TODO-  parents) for details).\nIn your actual pom file your basically just overwrite and extend the default settings.  But this principle is not just limited to the configuration. It also affects the folder structure.  The standard folder structure of a maven project looks like this:  project-home\n  |--- src\n  |     |--- main\n  |     |     |--- java\n  |     |     |--- resources\n  |     |--- test\n  |     |     |--- java\n  |     |     |--- resources\n  |--- target\n  |--- pom.xml  Your  project  folder only contains the pom file and whatever files your IDE needs.\nThe  src  folder contains your project (splitted into  main  for the actual application and  test  for\nall test related soruces) and the  target  folder contains everything that is produced by the build\n(including intermediate products).",
            "title": "Maven specific details"
        },
        {
            "location": "/01_basic_setup/basic_setup/index.html",
            "text": "Basic project setup\n\n\nThe first task is to start from almost nothing and make the project buildable.\n\n\nPlease take a look in the folder \ntasks/01_basic_setup\n. You will find a \npom.xml\n which is exactly what you will find on the\ninternet if you search for an example of a pom file.\n\n\nThe task now is to make the project buildable.\n\n\nIf you are ready execute \nmvn clean verify -Ptask1\n in the root of the project and reload this page.",
            "title": "Basic Project Setup"
        },
        {
            "location": "/01_basic_setup/basic_setup/index.html#basic-project-setup",
            "text": "The first task is to start from almost nothing and make the project buildable.  Please take a look in the folder  tasks/01_basic_setup . You will find a  pom.xml  which is exactly what you will find on the\ninternet if you search for an example of a pom file.  The task now is to make the project buildable.  If you are ready execute  mvn clean verify -Ptask1  in the root of the project and reload this page.",
            "title": "Basic project setup"
        },
        {
            "location": "/02_dependencies/dependencies/index.html",
            "text": "Adding Dependencies\n\n\nOne of the core features of Maven is to do dependency management for you. In former times you would\nhave to download all your dependencies yourself, copy them into your project and then modify the classpath\nto actually be able to use them. Maven will take care of all of this for you.\n\n\nIn the folder \n02_dependencies\n you will find a pom file that just describes a basic project.\nTo make it compile you will need to add a dependency to the \nguava library\n.\n\n\nIf you are ready execute \nmvn clean verify -Ptask2\n in the root of the project and reload this page.\n\n\nFinding dependency definitions\n\n\nTo add a dependency to your project you need to know the three values for \ngroupId\n, \nartifactId\n and \nversion\n that\nyou want to use. Usually there are two main ways to find out about these values:\n\n\nThe project website.\n\n\nIn the case of guava for example the readme actually states these information.\n\n\nThe maven central index.\n\n\nYou can always navigate to \nmaven central\n and then search for the artifact you are looking\nfor. In our case this would be \ngoogle guava\n. After selecting a version that suits your needs the website will\nshow you the dependency information to add to your project.",
            "title": "Adding Dependencies"
        },
        {
            "location": "/02_dependencies/dependencies/index.html#adding-dependencies",
            "text": "One of the core features of Maven is to do dependency management for you. In former times you would\nhave to download all your dependencies yourself, copy them into your project and then modify the classpath\nto actually be able to use them. Maven will take care of all of this for you.  In the folder  02_dependencies  you will find a pom file that just describes a basic project.\nTo make it compile you will need to add a dependency to the  guava library .  If you are ready execute  mvn clean verify -Ptask2  in the root of the project and reload this page.",
            "title": "Adding Dependencies"
        },
        {
            "location": "/02_dependencies/dependencies/index.html#finding-dependency-definitions",
            "text": "To add a dependency to your project you need to know the three values for  groupId ,  artifactId  and  version  that\nyou want to use. Usually there are two main ways to find out about these values:  The project website.  In the case of guava for example the readme actually states these information.  The maven central index.  You can always navigate to  maven central  and then search for the artifact you are looking\nfor. In our case this would be  google guava . After selecting a version that suits your needs the website will\nshow you the dependency information to add to your project.",
            "title": "Finding dependency definitions"
        },
        {
            "location": "/03_properties/properties/index.html",
            "text": "Properties and Defaults\n\n\nAs described \nearlier\n Maven has defaults for everything.\n\n\nIf you try to build this project by executing \nmvn clean verify -Ptask3\n you will notice that these defaults are\nsometimes not the best.\n\n\nLuckily that is easy to fix. As explained in the theoretical background you can overwrite the properties from\nthe parent and the defaults by specifying them again. The way to do it is described\n\nhere\n.\n\n\nThe properties in question are \nmaven.compiler.source\n and \nmaven.compiler.target\n which tell the maven\nsystem which Java version to assume for the source code and the output jar.\n\n\nThe task now is again to make the project build.",
            "title": "Properties and Defaults"
        },
        {
            "location": "/03_properties/properties/index.html#properties-and-defaults",
            "text": "As described  earlier  Maven has defaults for everything.  If you try to build this project by executing  mvn clean verify -Ptask3  you will notice that these defaults are\nsometimes not the best.  Luckily that is easy to fix. As explained in the theoretical background you can overwrite the properties from\nthe parent and the defaults by specifying them again. The way to do it is described here .  The properties in question are  maven.compiler.source  and  maven.compiler.target  which tell the maven\nsystem which Java version to assume for the source code and the output jar.  The task now is again to make the project build.",
            "title": "Properties and Defaults"
        },
        {
            "location": "/04_tests/tests/index.html",
            "text": "Tests\n\n\nOne of the main tasks of a build system is to ensure that all your testa are passing. If we go back to the\n\nMaven lifecycle\n you can see two phases covering tests.",
            "title": "Tests"
        },
        {
            "location": "/04_tests/tests/index.html#tests",
            "text": "One of the main tasks of a build system is to ensure that all your testa are passing. If we go back to the Maven lifecycle  you can see two phases covering tests.",
            "title": "Tests"
        }
    ]
}